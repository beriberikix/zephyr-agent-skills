# Sensor Subsystem

Zephyr's sensor subsystem provides a uniform API for interacting with various types of sensors (accelerometers, thermometers, light sensors, etc.).

## Core Concepts
- **Channels**: Specific types of data provided by a sensor (e.g., `SENSOR_CHAN_ACCEL_X`, `SENSOR_CHAN_AMBIENT_TEMP`).
- **Triggers**: Events generated by the sensor hardware (e.g., data ready, threshold exceeded).
- **Values**: Represented using `struct sensor_value` (integer part + fractional part in millionths).

## Reading Sensor Data

### 1. Fetch & Get API (Legacy/Common)
The standard way to read data. `fetch` grabs all data from the sensor, and `get` extracts specific channels.
```c
#include <zephyr/drivers/sensor.h>

const struct device *dev = DEVICE_DT_GET(DT_NODELABEL(my_sensor));
struct sensor_value temp;

if (sensor_sample_fetch(dev) == 0) {
    sensor_channel_get(dev, SENSOR_CHAN_AMBIENT_TEMP, &temp);
    printf("Temp: %d.%06d C\n", temp.val1, temp.val2);
}
```

### 2. Read & Decode API (Modern)
The newer, more efficient streaming-oriented API. Preferred for high-frequency or multi-sensor data.
```c
struct sensor_decode_context ctx;
sensor_read(dev, &ctx, ...);
```

## Professional Patterns (from Golioth)
- **Custom Work Queues**: Perform sensor sampling in a dedicated background work queue to avoid blocking high-priority application threads.
- **Threshold Triggers**: Use hardware interrupts for thresholds instead of polling to save power.
- **Shell Inspection**: Use the Zephyr shell (`sensor get <device> <channel>`) to verify hardware connectivity and readings at runtime.

## Kconfig Configuration
```kconfig
CONFIG_SENSOR=y
CONFIG_SENSOR_LOG_LEVEL_DBG=y # For development
```
